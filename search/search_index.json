{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#data-structures","title":"Data structures","text":"<p>In this library, we implemented some important data structures and seen how they work. We have:</p> <ul> <li> <p><code>Array_new</code>: This was our custom implementation of an array. It provided a way to store a contiguous sequence of elements and likely included basic array operations like initialization and element access. We used it as one of the underlying structures for our <code>Stack</code> implementation.</p> </li> <li> <p><code>Node</code>: This class served as the fundamental building block for our linked list and tree implementations. Each <code>Node</code> object held a <code>value</code> and references (<code>next</code> and optionally <code>prev</code> for doubly linked lists, <code>left</code> and <code>right</code> for trees) to other nodes in the data structure.</p> </li> <li> <p><code>LinkedList</code>: This class implemented the linked list data structure, utilizing <code>Node</code> objects. It supported both singly and doubly linked lists and provided methods for inserting, deleting, accessing, searching, reversing, and updating elements within the list. We used it as the underlying structure for our <code>Stack</code> and <code>Queue</code> implementations.</p> </li> <li> <p><code>Stack</code>: This class implemented the stack data structure, which follows the LIFO principle. It could be initialized with either an <code>Array_new</code> or a <code>LinkedList</code> object as its underlying storage. It provided methods for <code>push</code> (to add elements to the top), <code>pop_stack</code> (to remove and return the top element), <code>peek</code> (to view the top element), <code>isEmpty</code> (to check if the stack is empty), and <code>display_stack</code> (to show the stack's contents).</p> </li> <li> <p><code>Queue</code>: This class implemented the queue data structure, following the FIFO principle. It used a <code>LinkedList</code> as its underlying storage. It provided methods for <code>enqueue</code> (to add elements to the rear), <code>dequeue</code> (to remove and return the front element), <code>peek</code> (to view the front element), <code>rear</code> (to view the rear element), <code>isNull</code> (to check if the queue is empty), and <code>display_queue</code> (to show the queue's contents).</p> </li> <li> <p><code>BinaryTree</code>: This class inherited from the <code>Node</code> class and represented a binary tree. Each instance was a node that could have a left and a right child. It included methods for different tree traversals (<code>pre_order</code>, <code>in_order</code>, <code>post_order</code>), searching for nodes (<code>search_node</code>, <code>search_BST</code> for Binary Search Trees), and adding nodes while maintaining the BST property (<code>addnode</code>). It also had methods for building and drawing a graph representation of the tree using <code>networkx</code> and <code>matplotlib</code> (<code>build_graph</code>, <code>draw_graph</code>).</p> </li> </ul> <p>In essence, these classes provide the blueprints and functionalities for creating and manipulating different types of data structures, each designed for specific ways of organizing and accessing data.</p>"},{"location":"array/","title":"Array","text":"<pre><code># The `Array_new` Class: A Custom Array Implementation\n\nThis document describes the `Array_new` class, which provides a custom implementation of an array-like data structure in Python, leveraging the power and efficiency of the `numpy` library as its backend.\n\n## Class Definition\n\n```python\nimport numpy as np\n\nclass Array_new:\n  def __init__(self, data):\n    self.data = np.array(data)\n    self.shape = self.data.shape\n    self.size = np.array(data).size\n    self.dim = np.array(data).ndim\n\n  def __str__(self):\n    \"\"\"Returns a list where all the elements are transformed to strings\"\"\"\n    return f\"Data = {self.data}\"\n\n  def __getitem__(self, index):\n      if isinstance(index, int):\n          # Handle single index subscription\n          return self.data[index]\n      elif isinstance(index, slice):\n          # Handle slicing\n          start, stop, step = index.indices(len(self))\n          return Array_new(self.data[start:stop:step])  # Create a new Array_new object for the slice\n      else:\n          raise TypeError(\"Invalid index type\")\n  def __len__(self):\n    return len(self.data)\n\n\n  def max(self):\n      \"\"\"Returns the maximum value in the array.\"\"\"\n      return max(self.data)\n\n  def min(self):\n      \"\"\"Returns the minimum value in the array.\"\"\"\n      return min(self.data)\n\n  def sum(self):\n      \"\"\"Returns the sum of all elements in the array.\"\"\"\n      return sum(self.data)\n\n  def show_array(self):\n    print(self.data)\n\n  def pop_array(self):\n    a = self.data[-1]\n    self.data = self.data[:self.__len__()-1]\n    return a\n\n  def insert(self, elt, pos = -1):\n    return np.insert(np.array(self.data), pos, elt)\n\n\n  def append(self, NewElt):\n    self.data = np.append(self.data, NewElt)\n    self.shape = self.data.shape\n    self.size = self.data.size\n    self.dim = self.data.ndim\n\n\n  def mean(self):\n      \"\"\"Returns the mean (average) of the array elements.\"\"\"\n      return self.sum() / len(self) if len(self) else 0\n\n  def std(self):\n      \"\"\"Returns the standard deviation of the array elements.\"\"\"\n      mean = self.mean()\n      variance = sum([(x - mean) ** 2 for x in self.data]) / len(self)\n      return variance ** 0.5\n</code></pre>"},{"location":"array/#__init__self-data","title":"<code>__init__(self, data)</code>","text":"<ul> <li>Purpose: This is the constructor for the <code>Array_new</code> class. It initializes a new array object based on the input data.</li> <li>Parameters:<ul> <li><code>data</code>: An iterable (like a list or tuple) containing the initial elements of the array.</li> </ul> </li> <li>Functionality:<ul> <li>It converts the input <code>data</code> into a <code>numpy</code> array and stores it in the <code>self.data</code> attribute. This leverages <code>numpy</code>'s efficient array operations.</li> <li>It calculates and stores the <code>shape</code> (dimensions of the array), <code>size</code> (total number of elements), and <code>dim</code> (number of dimensions) of the <code>numpy</code> array.</li> </ul> </li> </ul>"},{"location":"array/#__str__self","title":"<code>__str__(self)</code>","text":"<ul> <li>Purpose: This special method defines how the <code>Array_new</code> object should be represented as a string.</li> <li>Functionality: It returns a formatted string that displays the <code>self.data</code> (the underlying <code>numpy</code> array).</li> </ul>"},{"location":"array/#__getitem__self-index","title":"<code>__getitem__(self, index)</code>","text":"<ul> <li>Purpose: This special method enables item access (using square brackets <code>[]</code>) for the <code>Array_new</code> object, similar to how you would access elements in a standard Python list or a <code>numpy</code> array.</li> <li>Parameters:<ul> <li><code>index</code>: The index or slice specifying the element(s) to retrieve.</li> </ul> </li> <li>Functionality:<ul> <li>Integer Index: If <code>index</code> is an integer, it returns the element at that specific position in the <code>self.data</code> array.</li> <li>Slice: If <code>index</code> is a slice object, it extracts the specified portion of the <code>self.data</code> array and returns a new <code>Array_new</code> object containing the sliced data. This ensures that slicing an <code>Array_new</code> object results in another <code>Array_new</code> object.</li> <li>Invalid Type: If <code>index</code> is of any other type, it raises a <code>TypeError</code> indicating an invalid index.</li> </ul> </li> </ul>"},{"location":"array/#__len__self","title":"<code>__len__(self)</code>","text":"<ul> <li>Purpose: This special method enables the use of the <code>len()</code> function on an <code>Array_new</code> object.</li> <li>Functionality: It returns the number of elements in the <code>self.data</code> array.</li> </ul>"},{"location":"array/#maxself","title":"<code>max(self)</code>","text":"<ul> <li>Purpose: Returns the maximum value present in the array.</li> <li>Functionality: It uses the built-in <code>max()</code> function on the <code>self.data</code> (the <code>numpy</code> array) to find and return the largest element.</li> </ul>"},{"location":"array/#minself","title":"<code>min(self)</code>","text":"<ul> <li>Purpose: Returns the minimum value present in the array.</li> <li>Functionality: It uses the built-in <code>min()</code> function on the <code>self.data</code> to find and return the smallest element.</li> </ul>"},{"location":"array/#sumself","title":"<code>sum(self)</code>","text":"<ul> <li>Purpose: Returns the sum of all the elements in the array.</li> <li>Functionality: It uses the built-in <code>sum()</code> function on the <code>self.data</code> to calculate and return the sum of all its elements.</li> </ul>"},{"location":"array/#show_arrayself","title":"<code>show_array(self)</code>","text":"<ul> <li>Purpose: Prints the underlying <code>numpy</code> array to the console.</li> <li>Functionality: It uses the <code>print()</code> function to display the contents of the <code>self.data</code> attribute.</li> </ul>"},{"location":"array/#pop_arrayself","title":"<code>pop_array(self)</code>","text":"<ul> <li>Purpose: Removes and returns the last element of the array, similar to the <code>pop()</code> method of a Python list.</li> <li>Functionality:<ul> <li>It stores the last element of <code>self.data</code> in a temporary variable <code>a</code>.</li> <li>It then updates <code>self.data</code> to contain all elements except the last one using slicing.</li> <li>Finally, it returns the removed element <code>a</code>.</li> </ul> </li> </ul>"},{"location":"array/#insertself-elt-pos-1","title":"<code>insert(self, elt, pos=-1)</code>","text":"<ul> <li>Purpose: Inserts a new element (<code>elt</code>) into the array at a specified position (<code>pos</code>).</li> <li>Parameters:<ul> <li><code>elt</code>: The element to be inserted.</li> <li><code>pos</code>: The index at which the element should be inserted. A negative index counts from the end of the array (default is -1, which inserts before the last element).</li> </ul> </li> <li>Functionality: It uses the <code>np.insert()</code> function from <code>numpy</code> to create a new <code>numpy</code> array with the element inserted at the given position. Note: This method returns a new <code>numpy</code> array and does not modify the <code>self.data</code> attribute in place. You would need to assign the result back to <code>self.data</code> if you want to update the array.</li> </ul>"},{"location":"array/#appendself-newelt","title":"<code>append(self, NewElt)</code>","text":"<ul> <li>Purpose: Adds a new element (<code>NewElt</code>) to the end of the array, similar to the <code>append()</code> method of a Python list.</li> <li>Parameters:<ul> <li><code>NewElt</code>: The element to be added to the end of the array.</li> </ul> </li> <li>Functionality:<ul> <li>It uses the <code>np.append()</code> function from <code>numpy</code> to create a new <code>numpy</code> array with the <code>NewElt</code> added at the end.</li> <li>It then updates the <code>self.data</code>, <code>self.shape</code>, <code>self.size</code>, and <code>self.dim</code> attributes of the <code>Array_new</code> object to reflect the changes.</li> </ul> </li> </ul>"},{"location":"array/#meanself","title":"<code>mean(self)</code>","text":"<ul> <li>Purpose: Calculates and returns the arithmetic mean (average) of all the elements in the array.</li> <li>Functionality:<ul> <li>It first calculates the sum of the array elements using <code>self.sum()</code>.</li> <li>It then divides the sum by the number of elements (obtained using <code>len(self)</code>) to get the mean.</li> <li>If the array is empty, it returns 0 to avoid division by zero.</li> </ul> </li> </ul>"},{"location":"array/#stdself","title":"<code>std(self)</code>","text":"<ul> <li>Purpose: Calculates and returns the standard deviation of the elements in the array. Standard deviation measures the spread or dispersion of the data around the mean.</li> <li>Functionality:<ul> <li>It first calculates the mean of the array using <code>self.mean()</code>.</li> <li>It then calculates the variance by summing the squared differences between each element and the mean, and dividing by the number of elements.</li> <li>Finally, it returns the square root of the variance, which is the standard deviation.</li> </ul> </li> </ul> <p>This <code>Array_new</code> class provides a convenient wrapper around <code>numpy</code> arrays, offering a more object-oriented interface with methods for common array operations while still benefiting from <code>numpy</code>'s performance for numerical computations.</p>"},{"location":"array/#example-usage-of-the-array_new-class","title":"Example Usage of the <code>Array_new</code> Class","text":"<p>This section provides practical examples of how to create and interact with <code>Array_new</code> objects, demonstrating the usage of various methods defined in the class.</p> <pre><code># Create an Array_new object\nmy_array = Array_new([1, 2, 3, 4, 5])\n\n# Access elements by index\nprint(my_array[0])  # Output: 1\nprint(my_array[2])  # Output: 3\n\n# Get the shape of the array\nprint(my_array.shape)  # Output: (5,)\n\n# Get the size of the array\nprint(my_array.size)  # Output: 5\n\n# Get the dimension of the array\nprint(my_array.dim)  # Output: 1\n\n# Get the maximum value\nprint(my_array.max())  # Output: 5\n\n# Get the minimum value\nprint(my_array.min())  # Output: 1\n\n# Get the sum of all elements\nprint(my_array.sum())  # Output: 15\n\n# Get the mean (average)\nprint(my_array.mean())  # Output: 3.0\n\n# Get the standard deviation\nprint(my_array.std())  # Output: 1.4142135623730951\n\n# Display the array\nmy_array.show_array()\n\n# Remove and return the last element\nremoved_element = my_array.pop_array()\nprint(f\"Removed element: {removed_element}\")\n\n# Insert element at a specific position (default at the end)\ninserted_array = my_array.insert(6, 2) # Note: insert returns a new numpy array\nprint(f\"Array after insertion: {inserted_array}\")\n\n# Append new element at the end\nmy_array.append(7)\nprint(my_array)\n</code></pre> <p>Explanation of the Example:</p> <ol> <li> <p>Creating an <code>Array_new</code> Object: <code>python     my_array = Array_new([1, 2, 3, 4, 5])</code>     This line creates an instance of the <code>Array_new</code> class, initializing it with a Python list <code>[1, 2, 3, 4, 5]</code>. The constructor converts this list into a <code>numpy</code> array and sets the <code>shape</code>, <code>size</code>, and <code>dim</code> attributes.</p> </li> <li> <p>Accessing Elements by Index: <code>python     print(my_array[0])  # Output: 1     print(my_array[2])  # Output: 3</code>     This demonstrates the use of the <code>__getitem__</code> method to access elements at specific indices (0-based).</p> </li> <li> <p>Getting Array Properties: <code>python     print(my_array.shape)  # Output: (5,)     print(my_array.size)   # Output: 5     print(my_array.dim)    # Output: 1</code>     These lines access the <code>shape</code> (a tuple indicating the dimensions), <code>size</code> (the total number of elements), and <code>dim</code> (the number of dimensions) of the array.</p> </li> <li> <p>Statistical Operations: <code>python     print(my_array.max())   # Output: 5     print(my_array.min())   # Output: 1     print(my_array.sum())   # Output: 15     print(my_array.mean())  # Output: 3.0     print(my_array.std())   # Output: 1.4142135623730951</code>     These lines demonstrate the use of the <code>max()</code>, <code>min()</code>, <code>sum()</code>, <code>mean()</code>, and <code>std()</code> methods to perform basic statistical calculations on the array elements.</p> </li> <li> <p>Displaying the Array: <code>python     my_array.show_array()</code>     This calls the <code>show_array()</code> method, which prints the underlying <code>numpy</code> array to the console.</p> </li> <li> <p>Removing the Last Element: <code>python     removed_element = my_array.pop_array()     print(f\"Removed element: {removed_element}\")</code>     The <code>pop_array()</code> method removes and returns the last element of the array.</p> </li> <li> <p>Inserting an Element: <code>python     inserted_array = my_array.insert(6, 2) # Note: insert returns a new numpy array     print(f\"Array after insertion: {inserted_array}\")</code>     The <code>insert()</code> method inserts the value <code>6</code> at index <code>2</code>. Important: As noted in the code comment, the <code>insert()</code> method from <code>numpy</code> returns a new <code>numpy</code> array. The original <code>my_array</code> object's <code>data</code> attribute is not modified in place by this implementation.</p> </li> <li> <p>Appending an Element: <code>python     my_array.append(7)     print(my_array)</code>     The <code>append()</code> method adds the value <code>7</code> to the end of the array. This method does modify the <code>self.data</code> attribute of the <code>my_array</code> object in place and updates its <code>shape</code>, <code>size</code>, and <code>dim</code>.</p> </li> </ol> <p>This example provides a clear illustration of how to use the <code>Array_new</code> class for common array operations. Pay close attention to the behavior of the <code>insert()</code> method, which returns a new array rather than modifying the original in place. ```</p>"},{"location":"linked_list/","title":"Linked List","text":"<pre><code># The `Node` and `LinkedList` Classes for Linked List Implementation\n\nThis document explains the `Node` and `LinkedList` classes, which provide a comprehensive implementation of linked list data structures, supporting both singly and doubly linked lists.\n\n## `Node` Class\n\nThe `Node` class represents a single node in the linked list. Each node contains a `value` and references to the `next` node (for singly linked lists) and optionally to the `prev` node (for doubly linked lists).\n\n```python\nclass Node:\n  def __init__(self, value, next = None, prev = None):\n    self.value = value\n    self.next = next\n    self.prev = prev\n</code></pre>"},{"location":"linked_list/#__init__self-value-nextnone-prevnone","title":"<code>__init__(self, value, next=None, prev=None)</code>","text":"<ul> <li>Purpose: This is the constructor for the <code>Node</code> class. It initializes a new node.</li> <li>Parameters:<ul> <li><code>value</code>: The data to be stored in this node.</li> <li><code>next</code>: An optional reference to the next node in the list. Defaults to <code>None</code>.</li> <li><code>prev</code>: An optional reference to the previous node in the list (used for doubly linked lists). Defaults to <code>None</code>.</li> </ul> </li> <li>Functionality: When a <code>Node</code> object is created, this method sets the <code>value</code>, <code>next</code>, and <code>prev</code> attributes to the provided values.</li> </ul>"},{"location":"linked_list/#linkedlist-class","title":"<code>LinkedList</code> Class","text":"<p>The <code>LinkedList</code> class implements the linked list data structure, providing methods for insertion, deletion, traversal, searching, and other common linked list operations. It supports both singly and doubly linked lists through the <code>double</code> flag in the constructor.</p> <pre><code>class LinkedList:\n  def __init__(self,double = False):\n    self.head = None\n    self.double = double\n\n  # Inserting a node at the beginning of the list\n  def InsertAtBeg(self, item):\n    if self.head:\n      new = Node(item)\n      new.next = self.head\n      if self.double:\n        self.head.prev = new\n      self.head = new\n    else:\n      self.head = Node(item)\n\n  # Inserting a node at a particular position of the list\n  def InsertAtPos(self, item, index):\n    node = Node(item)\n    if ((not self.head) and (index == 0)) or (index == 0):\n      self.InsertAtBeg(item)\n    else:\n      i = 0\n      temp = self.head\n\n      while i &lt; index and temp.next != None:\n        i += 1\n        prev = temp\n        temp = temp.next\n\n      if i == index:\n        node.next = temp\n        prev.next = node\n        if self.double:\n          temp.prev = node\n          node.prev = prev\n\n      elif index == i+1:\n        self.InsertAtEnd(item)\n      else:\n        raise IndexError(\"This index is out of bounds\")\n\n\n  # Inserting a node at the end of the list\n  def InsertAtEnd(self, item):\n    last = Node(item)\n    if self.head:\n      temp = self.head\n      while temp.next:\n        prev = temp\n        temp = temp.next\n      temp.next = last\n      if self.double:\n        last.prev = temp\n    else:\n      self.head = last\n\n  # Deleting a node with its index\n  def deleteItem(self, index):\n    i = 0\n    tem = self.head\n    if not self.head:\n      raise IndexError(\"The list is empty\")\n      pass\n    else:\n      if index == 0:\n        self.head = self.head.next\n      while tem.next and i &lt; index:\n        prev = tem\n        tem = tem.next\n        i += 1\n      if i == index and index != 0:\n        if self.double:\n          tem.next.prev = prev\n        prev.next = tem.next\n      elif not tem.next:\n        raise IndexError(f'There is less than {index} elements in the linked list')\n\n  # Get_length: count the number of nodes in the list\n\n  def get_length(self):\n    if not self.head:\n      return 0\n    else:\n      i = 1\n      temp = self.head\n      while temp.next:\n        i += 1\n        temp = temp.next\n      return i\n\n  # Access: return the value of the node at the given position\n  def access(self, index):\n    if self.get_length() == 0 :\n      print(f\"The list is empty\")\n    elif self.get_length() &lt;= index:\n     raise IndexError(\"Index out of bound\")\n    else:\n      temp = self.head\n      for k in range(index):\n        temp = temp.next\n      return temp.value\n\n\n  # Allow subscription\n\n  def __getitem__(self, index):\n      if isinstance(index, int):\n      # Handle single index subscription\n        if index &gt;= 0:\n          return self.access(index)\n        else:\n          if abs(index) &lt;= self.get_length():\n            return self.access(self.get_length() + index)\n          else:\n            raise IndexError(\"Index out of bound\")\n      else:\n        raise TypeError(\"Invalid index type\")\n\n  # Search: look for a node with a specific value or property\n\n  def search(self, key):\n    '''Returns a list of indices of the nodes with value = key\n    The list is empty if there is no node with value = key'''\n\n    if self.get_length() == 0:\n      raise IndexError(f\"The list is empty\")\n    else:\n      indices = []\n      i = 0\n      temp = self.head\n      while temp is not None:\n        if temp.value == key:\n          indices.append(i)\n        temp = temp.next\n        i += 1\n      return indices\n\n  # Reverse the linked list\n\n  def reverse_list(self):\n    if self.IsEmpty():\n      raise IndexError(\"The list is empty\")\n    else:\n      new_list = LinkedList(self.double)\n      temp = self.head\n\n      while temp.next:\n        new_list.InsertAtBeg(temp.value)\n        temp = temp.next\n      new_list.InsertAtBeg(temp.value)\n      return new_list\n\n  # Update a value at a particular position\n  def update(self, new_val, pos):\n    n = self.get_length()\n    if n != 0:\n      tem = self.head\n      if pos &lt;= n and pos &gt;= 0 or (pos &lt; 0 and pos &gt;= -n):\n        if pos &lt; 0 :\n          for i in range(n + pos):\n            tem = tem.next\n          tem.value = new_val\n        else:\n          for i in range(pos):\n            tem = tem.next\n          tem.value = new_val\n      else:\n        raise IndexError(f\"Index {pos} out of range\")\n    else:\n      raise IndexError(f\"Cannot update element in an empty list\")\n  def IsEmpty(self):\n    return  self.get_length() == 0\n\n  def last_node(self):\n    if self.head is None:\n      raise IndexError(\"The linked list is empty\")\n    else:\n      tem = self.head\n      while(tem.next):\n        tem = tem.next\n      return tem\n\n  def concatenate(self, L1, L2):\n    pass\n\n  def display(self):\n      node = self.head\n\n      a = \"&lt;--&gt;\" if self.double else \"-&gt;\"\n      while node:\n          print(node.value, end = a)\n          node = node.next\n      print('')\n</code></pre>"},{"location":"linked_list/#__init__self-doublefalse","title":"<code>__init__(self, double=False)</code>","text":"<ul> <li>Purpose: This is the constructor for the <code>LinkedList</code> class. It initializes an empty linked list.</li> <li>Parameters:<ul> <li><code>double</code>: A boolean flag indicating whether the linked list should be doubly linked (<code>True</code>) or singly linked (<code>False</code>). Defaults to <code>False</code> (singly linked).</li> </ul> </li> <li>Functionality: It sets the <code>head</code> attribute to <code>None</code> (indicating an empty list) and stores the <code>double</code> flag.</li> </ul>"},{"location":"linked_list/#insertatbegself-item","title":"<code>InsertAtBeg(self, item)</code>","text":"<ul> <li>Purpose: Inserts a new node with the given <code>item</code> at the beginning of the list.</li> <li>Parameters:<ul> <li><code>item</code>: The value to be inserted into the new node.</li> </ul> </li> <li>Functionality:<ul> <li>If the list is not empty, it creates a new <code>Node</code>, sets its <code>next</code> pointer to the current <code>head</code>, and updates the <code>prev</code> pointer of the old <code>head</code> if it's a doubly linked list. Finally, it sets the <code>head</code> to the new node.</li> <li>If the list is empty, it creates a new <code>Node</code> and sets it as the <code>head</code>.</li> </ul> </li> </ul>"},{"location":"linked_list/#insertatposself-item-index","title":"<code>InsertAtPos(self, item, index)</code>","text":"<ul> <li>Purpose: Inserts a new node with the given <code>item</code> at a specific <code>index</code> in the list.</li> <li>Parameters:<ul> <li><code>item</code>: The value to be inserted.</li> <li><code>index</code>: The position at which to insert the new node (0-based).</li> </ul> </li> <li>Functionality:<ul> <li>If the list is empty and the index is 0, or if the index is 0, it calls <code>InsertAtBeg</code>.</li> <li>Otherwise, it iterates through the list until it reaches the specified <code>index</code> or the end of the list.</li> <li>If the <code>index</code> is reached, it inserts the new node at that position, updating the <code>next</code> and <code>prev</code> pointers of the surrounding nodes if it's a doubly linked list.</li> <li>If the <code>index</code> is one position beyond the current end, it calls <code>InsertAtEnd</code>.</li> <li>If the <code>index</code> is out of bounds, it raises an <code>IndexError</code>.</li> </ul> </li> </ul>"},{"location":"linked_list/#insertatendself-item","title":"<code>InsertAtEnd(self, item)</code>","text":"<ul> <li>Purpose: Inserts a new node with the given <code>item</code> at the end of the list.</li> <li>Parameters:<ul> <li><code>item</code>: The value to be inserted.</li> </ul> </li> <li>Functionality:<ul> <li>If the list is not empty, it traverses to the last node and appends the new node, updating the <code>prev</code> pointer of the new node if it's a doubly linked list.</li> <li>If the list is empty, it creates a new <code>Node</code> and sets it as the <code>head</code>.</li> </ul> </li> </ul>"},{"location":"linked_list/#deleteitemself-index","title":"<code>deleteItem(self, index)</code>","text":"<ul> <li>Purpose: Deletes the node at the specified <code>index</code> from the list.</li> <li>Parameters:<ul> <li><code>index</code>: The position of the node to delete (0-based).</li> </ul> </li> <li>Functionality:<ul> <li>If the list is empty, it raises an <code>IndexError</code>.</li> <li>If the <code>index</code> is 0, it updates the <code>head</code> to the next node.</li> <li>Otherwise, it iterates to the node at the given <code>index</code>. Once found, it updates the <code>next</code> pointer of the previous node to skip the current node. If it's a doubly linked list, it also updates the <code>prev</code> pointer of the next node.</li> <li>If the <code>index</code> is out of bounds, it raises an <code>IndexError</code>.</li> </ul> </li> </ul>"},{"location":"linked_list/#get_lengthself","title":"<code>get_length(self)</code>","text":"<ul> <li>Purpose: Returns the number of nodes in the linked list.</li> <li>Functionality: It traverses the list and counts the number of nodes.</li> </ul>"},{"location":"linked_list/#accessself-index","title":"<code>access(self, index)</code>","text":"<ul> <li>Purpose: Returns the value of the node at the specified <code>index</code>.</li> <li>Parameters:<ul> <li><code>index</code>: The position of the node to access (0-based).</li> </ul> </li> <li>Functionality:<ul> <li>If the list is empty or the <code>index</code> is out of bounds, it raises an <code>IndexError</code>.</li> <li>Otherwise, it traverses to the node at the given <code>index</code> and returns its <code>value</code>.</li> </ul> </li> </ul>"},{"location":"linked_list/#__getitem__self-index","title":"<code>__getitem__(self, index)</code>","text":"<ul> <li>Purpose: Enables accessing elements of the linked list using index-based subscription (e.g., <code>list[0]</code>).</li> <li>Parameters:<ul> <li><code>index</code>: The index of the element to access. Supports both positive and negative indexing.</li> </ul> </li> <li>Functionality:<ul> <li>If the <code>index</code> is a non-negative integer, it calls the <code>access()</code> method.</li> <li>If the <code>index</code> is a negative integer, it calculates the corresponding positive index from the end of the list and calls <code>access()</code>.</li> <li>If the <code>index</code> is out of bounds, it raises an <code>IndexError</code>.</li> <li>If the <code>index</code> is not an integer, it raises a <code>TypeError</code>.</li> </ul> </li> </ul>"},{"location":"linked_list/#searchself-key","title":"<code>search(self, key)</code>","text":"<ul> <li>Purpose: Searches for nodes with a specific <code>key</code> (value) and returns a list of their indices.</li> <li>Parameters:<ul> <li><code>key</code>: The value to search for.</li> </ul> </li> <li>Functionality:<ul> <li>If the list is empty, it raises an <code>IndexError</code>.</li> <li>Otherwise, it traverses the list and appends the index of each node whose <code>value</code> matches the <code>key</code> to a list.</li> <li>It returns the list of indices.</li> </ul> </li> </ul>"},{"location":"linked_list/#reverse_listself","title":"<code>reverse_list(self)</code>","text":"<ul> <li>Purpose: Creates and returns a new linked list that is the reverse of the original list.</li> <li>Functionality: It iterates through the original list and inserts each node's value at the beginning of the new list, effectively reversing the order. The <code>double</code> property of the new list is the same as the original.</li> </ul>"},{"location":"linked_list/#updateself-new_val-pos","title":"<code>update(self, new_val, pos)</code>","text":"<ul> <li>Purpose: Updates the value of the node at a particular <code>pos</code> (index) with <code>new_val</code>.</li> <li>Parameters:<ul> <li><code>new_val</code>: The new value to set.</li> <li><code>pos</code>: The index of the node to update (supports positive and negative indexing).</li> </ul> </li> <li>Functionality:<ul> <li>If the list is not empty and the <code>pos</code> is within the valid range, it traverses to the node at the given <code>pos</code> and updates its <code>value</code>.</li> <li>If the list is empty or the <code>pos</code> is out of bounds, it raises an <code>IndexError</code>.</li> </ul> </li> </ul>"},{"location":"linked_list/#isemptyself","title":"<code>IsEmpty(self)</code>","text":"<ul> <li>Purpose: Returns <code>True</code> if the linked list is empty (head is <code>None</code>), and <code>False</code> otherwise.</li> </ul>"},{"location":"linked_list/#last_nodeself","title":"<code>last_node(self)</code>","text":"<ul> <li>Purpose: Returns the last node in the linked list.</li> <li>Functionality: It traverses the list until it reaches the last node (the node whose <code>next</code> pointer is <code>None</code>). If the list is empty, it raises an <code>IndexError</code>.</li> </ul>"},{"location":"linked_list/#displayself","title":"<code>display(self)</code>","text":"<ul> <li>Purpose: Prints the elements of the linked list.</li> <li>Functionality: It traverses the list and prints the <code>value</code> of each node. For doubly linked lists, it indicates the bidirectional connections (<code>&lt;--&gt;</code>), and for singly linked lists, it indicates unidirectional connections (<code>-&gt;</code>). It ends with a newline character.</li> </ul>"},{"location":"linked_list/#example-usage-of-the-linkedlist-class","title":"Example Usage of the <code>LinkedList</code> Class","text":"<p>This section provides practical examples of how to create and interact with <code>LinkedList</code> objects, demonstrating the usage of various methods defined in the class.</p> <pre><code># Create a new LinkedList\nmy_list = LinkedList()\n\n# Insert elements at the beginning\nmy_list.InsertAtBeg(3)\nmy_list.InsertAtBeg(2)\nmy_list.InsertAtBeg(1)\n\n# Insert an element at a specific position\nmy_list.InsertAtPos(4, 2)  # Insert 4 at index 2\n\n# Insert an element at the end\nmy_list.InsertAtEnd(5)\n\n# Display the list\nmy_list.display()  # Output: 1-&gt;2-&gt;4-&gt;3-&gt;5-&gt;\n\n# Access an element by index\nelement = my_list[2]  # Access element at index 2\nprint(f\"Element at index 2: {element}\")  # Output: Element at index 2: 4\n\n# Get the length of the list\nlength = my_list.get_length()\nprint(f\"Length of the list: {length}\")  # Output: Length of the list: 5\n\n# Search for an element\nindices = my_list.search(3)  # Search for the element 3\nprint(f\"Indices of element 3: {indices}\")  # Output: Indices of element 3: [3]\n\n# Delete an element by index\nmy_list.deleteItem(2)  # Delete element at index 2\n\n# Display the list after deletion\nmy_list.display()  # Output: 1-&gt;2-&gt;3-&gt;5-&gt;\n\n# Reverse the list\nreversed_list = my_list.reverse_list()\nreversed_list.display()  # Output: 5-&gt;3-&gt;2-&gt;1-&gt;\n\n\n# Update the value at a particular position\nmy_list.update(10, 1)\nmy_list.display() # Output: 1-&gt;10-&gt;3-&gt;5-&gt;\n</code></pre> <p>Explanation of the Example:</p> <ol> <li> <p>Creating a <code>LinkedList</code> Object: <code>python     my_list = LinkedList()</code>     An instance of the <code>LinkedList</code> class is created. By default, it's initialized as a singly linked list (<code>double=False</code>).</p> </li> <li> <p>Inserting at the Beginning: <code>python     my_list.InsertAtBeg(3)     my_list.InsertAtBeg(2)     my_list.InsertAtBeg(1)</code>     The <code>InsertAtBeg()</code> method adds new nodes at the beginning of the list. So, the list becomes <code>1 -&gt; 2 -&gt; 3</code>.</p> </li> <li> <p>Inserting at a Specific Position: <code>python     my_list.InsertAtPos(4, 2)  # Insert 4 at index 2</code>     The <code>InsertAtPos()</code> method inserts a new node with the value <code>4</code> at index <code>2</code> (0-based). The list becomes <code>1 -&gt; 2 -&gt; 4 -&gt; 3</code>.</p> </li> <li> <p>Inserting at the End: <code>python     my_list.InsertAtEnd(5)</code>     The <code>InsertAtEnd()</code> method adds a new node with the value <code>5</code> at the end of the list. The list becomes <code>1 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</code>.</p> </li> <li> <p>Displaying the List: <code>python     my_list.display()  # Output: 1-&gt;2-&gt;4-&gt;3-&gt;5-&gt;</code>     The <code>display()</code> method prints the values of the nodes in the list, separated by <code>-&gt;</code> for a singly linked list.</p> </li> <li> <p>Accessing an Element by Index: <code>python     element = my_list[2]  # Access element at index 2     print(f\"Element at index 2: {element}\")  # Output: Element at index 2: 4</code>     The <code>__getitem__()</code> method allows accessing elements using index-based subscription. Here, it retrieves the element at index <code>2</code>, which is <code>4</code>.</p> </li> <li> <p>Getting the Length: <code>python     length = my_list.get_length()     print(f\"Length of the list: {length}\")  # Output: Length of the list: 5</code>     The <code>get_length()</code> method returns the number of nodes in the list.</p> </li> <li> <p>Searching for an Element: <code>python     indices = my_list.search(3)  # Search for the element 3     print(f\"Indices of element 3: {indices}\")  # Output: Indices of element 3: [3]</code>     The <code>search()</code> method finds all occurrences of a given value and returns a list of their indices. Here, the value <code>3</code> is found at index <code>3</code>.</p> </li> <li> <p>Deleting an Element by Index: <code>python     my_list.deleteItem(2)  # Delete element at index 2</code>     The <code>deleteItem()</code> method removes the node at the specified index. Here, the node at index <code>2</code> (which was <code>4</code>) is removed, and the list becomes <code>1 -&gt; 2 -&gt; 3 -&gt; 5</code>.</p> </li> <li> <p>Displaying After Deletion: <code>python     my_list.display()  # Output: 1-&gt;2-&gt;3-&gt;5-&gt;</code>     The <code>display()</code> method shows the list after the deletion.</p> </li> <li> <p>Reversing the List: <code>python     reversed_list = my_list.reverse_list()     reversed_list.display()  # Output: 5-&gt;3-&gt;2-&gt;1-&gt;</code>     The <code>reverse_list()</code> method creates a new linked list with the nodes in reverse order.</p> </li> <li> <p>Updating a Value: <code>python     my_list.update(10, 1)     my_list.display() # Output: 1-&gt;10-&gt;3-&gt;5-&gt;</code>     The <code>update()</code> method changes the value of the node at the specified index. Here, the value at index <code>1</code> (which was <code>2</code>) is updated to <code>10</code>. ```</p> </li> </ol>"},{"location":"node/","title":"The <code>Node</code> Class for Tree Structures","text":"<p>This document explains the <code>Node</code> class, which serves as a fundamental building block for creating tree-like data structures, particularly binary trees. This class includes functionality to represent a node with a value and references to its left and right children, as well as methods for building and drawing a graph representation of the tree using the <code>networkx</code> and <code>matplotlib</code> libraries.</p>"},{"location":"node/#class-definition","title":"Class Definition","text":"<pre><code>import networkx as nx\nimport matplotlib.pyplot as plt\n\nclass Node:\n  def __init__(self, value, right = None, left = None):\n    self.value = value\n    self.right = right\n    self.left = left\n\n\n  def build_graph(self, graph=None, pos=None, depth=0, x=0, dx=0.5):\n      if graph is None:\n          graph = nx.DiGraph()\n      if pos is None:\n          pos = {}\n\n      graph.add_node(self.value)\n      pos[self.value] = (x, -depth)  # Invert depth for vertical tree\n\n      if self.left:\n          graph.add_edge(self.value, self.left.value)\n          graph, pos = self.left.build_graph(graph, pos, depth + 1, x - dx / 2, dx / 2)\n      if self.right:\n          graph.add_edge(self.value, self.right.value)\n          graph, pos = self.right.build_graph(graph, pos, depth + 1, x + dx / 2, dx / 2)\n\n      return graph, pos\n\n  def draw_graph(self):\n      \"\"\"\n      Builds the graph representation and then draws it using matplotlib.\n      \"\"\"\n      graph, pos = self.build_graph()\n      nx.draw(graph, pos, with_labels=True, node_size=1000, node_color=\"skyblue\",\n              font_size=10, font_weight=\"bold\", arrows=False)\n      plt.show()\n</code></pre>"},{"location":"node/#__init__self-value-rightnone-leftnone","title":"<code>__init__(self, value, right=None, left=None)</code>","text":"<ul> <li>Purpose: This is the constructor for the <code>Node</code> class. It initializes a new node object.</li> <li>Parameters:<ul> <li><code>value</code>: The data to be stored within this node. This can be any Python object.</li> <li><code>left</code>: An optional reference to the left child node. If no left child is specified during initialization, it defaults to <code>None</code>.</li> <li><code>right</code>: An optional reference to the right child node. If no right child is specified during initialization, it defaults to <code>None</code>.</li> </ul> </li> <li>Functionality: When a <code>Node</code> object is created, this method sets the <code>value</code> attribute to the provided <code>value</code>, the <code>left</code> attribute to the provided <code>left</code> node (or <code>None</code>), and the <code>right</code> attribute to the provided <code>right</code> node (or <code>None</code>). These attributes allow you to link nodes together to form tree structures.</li> </ul>"},{"location":"node/#build_graphself-graphnone-posnone-depth0-x0-dx05","title":"<code>build_graph(self, graph=None, pos=None, depth=0, x=0, dx=0.5)</code>","text":"<ul> <li>Purpose: This method recursively constructs a directed graph representation of the tree rooted at the current <code>Node</code> object using the <code>networkx</code> library. This graph is designed to be used for visualization.</li> <li>Parameters:<ul> <li><code>graph</code>: An optional <code>networkx.DiGraph</code> object. If no graph is provided, a new one is created. This allows you to build the graph incrementally across multiple nodes.</li> <li><code>pos</code>: An optional dictionary to store the (x, y) coordinates of each node in the graph for plotting. If no position dictionary is provided, a new one is created.</li> <li><code>depth</code>: The current depth of the node in the tree. This is used to determine the vertical position of the node in the graph. The root node typically has a depth of 0.</li> <li><code>x</code>: The horizontal position of the current node. This is used to position nodes side by side.</li> <li><code>dx</code>: The horizontal spacing factor between child nodes. This helps to prevent nodes from overlapping in the visualization.</li> </ul> </li> <li>Functionality:<ol> <li>Initialization: If <code>graph</code> or <code>pos</code> are not provided, they are initialized as a new directed graph and an empty dictionary, respectively.</li> <li>Add Current Node: The <code>value</code> of the current node is added as a node to the <code>graph</code>. Its position in the 2D layout is calculated based on its <code>depth</code> and <code>x</code> coordinate and stored in the <code>pos</code> dictionary. The depth is negated (<code>-depth</code>) to create a visual representation where deeper levels of the tree appear lower.</li> <li>Recursive Calls for Children:<ul> <li>If the current node has a <code>left</code> child, the <code>build_graph</code> method is recursively called on the <code>left</code> child. The <code>depth</code> is incremented, and the horizontal position <code>x</code> is adjusted to the left (<code>x - dx / 2</code>). The <code>dx</code> value is halved for each level to create tighter spacing at deeper levels. An edge is added to the <code>graph</code> connecting the current node to its left child.</li> <li>Similarly, if the current node has a <code>right</code> child, <code>build_graph</code> is called recursively on the <code>right</code> child with an incremented <code>depth</code> and an adjusted horizontal position to the right (<code>x + dx / 2</code>). An edge is added connecting the current node to its right child.</li> </ul> </li> <li>Return Values: The method returns the constructed <code>graph</code> and the <code>pos</code> dictionary containing the layout of the nodes.</li> </ol> </li> </ul>"},{"location":"node/#draw_graphself","title":"<code>draw_graph(self)</code>","text":"<ul> <li>Purpose: This method utilizes the <code>build_graph</code> method to create the graph representation of the tree and then uses the <code>matplotlib</code> library to visually render this graph.</li> <li>Parameters: This method does not take any explicit parameters.</li> <li>Functionality:<ol> <li>Build the Graph: It calls the <code>self.build_graph()</code> method to get the <code>networkx</code> graph object (<code>graph</code>) and the node position dictionary (<code>pos</code>).</li> <li>Draw the Graph: It uses the <code>nx.draw()</code> function from <code>networkx</code> with the following arguments:<ul> <li><code>graph</code>: The graph to be drawn.</li> <li><code>pos</code>: The dictionary of node positions calculated by <code>build_graph</code>.</li> <li><code>with_labels=True</code>: Ensures that the node values are displayed as labels on the nodes.</li> <li><code>node_size=1000</code>: Sets the size of the circular nodes in the visualization.</li> <li><code>node_color=\"skyblue\"</code>: Sets the fill color of the nodes.</li> <li><code>font_size=10</code>, <code>font_weight=\"bold\"</code>: Styles the text labels on the nodes.</li> <li><code>arrows=False</code>: Prevents the drawing of arrows on the edges, as we are representing an undirected tree structure visually (even though <code>DiGraph</code> is used internally for layout purposes).</li> </ul> </li> <li>Show the Plot: Finally, <code>plt.show()</code> from <code>matplotlib.pyplot</code> is called to display the generated graph visualization in a separate window.</li> </ol> </li> </ul>"},{"location":"node/#usage","title":"Usage","text":"<p>This <code>Node</code> class can be used as the basis for creating various tree-based data structures, such as binary trees, binary search trees, and more complex tree structures. By linking <code>Node</code> objects using their <code>left</code> and <code>right</code> attributes, you can build the desired tree topology. The <code>build_graph</code> and <code>draw_graph</code> methods provide a convenient way to visualize these tree structures for debugging, understanding, or presentation purposes. You would typically create a root <code>Node</code> object and then connect other <code>Node</code> objects as its descendants to build the tree. Then, calling <code>draw_graph()</code> on the root node would visualize the entire connected tree.</p> <pre><code>## Example Usage\n\nThis section demonstrates how to create a simple binary tree using the `Node` class and visualize it using the `draw_graph()` method. It also shows how to access the underlying `networkx` graph object and the node positions.\n\n```python\n# Example usage:\nroot = Node(8)\nroot.left = Node(3)\nroot.right = Node(10)\nroot.left.left = Node(1)\nroot.left.right = Node(6)\nroot.left.right.right = Node(7)\nroot.left.right.left = Node(4)\nroot.right.right = Node(14)\nroot.right.right.left = Node(13)\n\n# Drawing the graph of the tree rooted at 'root'\nroot.draw_graph()\n\n# get the graph object and position:\ntree_graph, tree_pos = root.build_graph()\n</code></pre> <p>Explanation:</p> <ol> <li> <p>Creating the Tree:</p> <ul> <li>We start by creating the root node of the tree with the value <code>8</code>:   <code>python   root = Node(8)</code></li> <li>Then, we create the left and right children of the root node:   <code>python   root.left = Node(3)   root.right = Node(10)</code></li> <li>We continue this process to build the subsequent levels of the tree, assigning left and right children to the existing nodes. This creates a specific tree structure.</li> </ul> </li> <li> <p>Drawing the Graph:</p> <ul> <li>The <code>draw_graph()</code> method is called on the <code>root</code> node:   <code>python   root.draw_graph()</code></li> <li>This initiates the process of building the <code>networkx</code> graph representation of the entire tree (starting from the <code>root</code>) and then uses <code>matplotlib</code> to display a visual representation of the tree structure. Each node in the tree will be shown with its value, and the connections between parent and child nodes will be represented by edges.</li> </ul> </li> <li> <p>Accessing the Graph Object and Positions:</p> <ul> <li>The <code>build_graph()</code> method can also be called directly if you need to access the underlying <code>networkx</code> graph object and the calculated positions of the nodes for further manipulation or analysis:   <code>python   tree_graph, tree_pos = root.build_graph()</code></li> <li><code>tree_graph</code>: This variable will hold the <code>networkx.DiGraph</code> object representing the tree. You can use <code>networkx</code> functions on this object to analyze the tree's properties (e.g., number of nodes, edges, connectivity).</li> <li><code>tree_pos</code>: This variable will hold a dictionary where the keys are the node values and the values are their (x, y) coordinates in the layout generated for visualization. This can be useful if you want to customize the drawing or use the layout information for other purposes.</li> </ul> </li> </ol> <p>This example demonstrates how easily you can create a tree structure using the <code>Node</code> class and visualize it with a single method call. The ability to access the underlying graph object also provides flexibility for more advanced operations. ```</p>"},{"location":"queue/","title":"Queue","text":"<pre><code># The `Queue` Class: A Queue Implementation using `LinkedList`\n\nThis page describes the `Queue` class, which implements a queue data structure using our custom `LinkedList` class as its underlying storage.\n\n```python\nfrom .linked_lists import LinkedList\n\nclass Queue:\n    \"\"\"N is the max size of our queue\"\"\"\n    N = 20\n\n\n    def __init__(self, para=None):  # Initialize with an optional LinkedList\n        if para is None:\n            self.queue = LinkedList()  # Create an empty LinkedList if not provided\n        else:\n            self.queue = para  # Use the provided LinkedList\n        self.size = self.queue.get_length()  # Initialize size\n\n    def enqueue(self, new):\n        if not self.isFull():\n            self.queue.InsertAtEnd(new)  # Use InsertAtEnd for LinkedList\n            self.size += 1  # Update size\n        else:\n            raise IndexError(\"The queue is full\")\n\n    def isNull(self):\n        return self.size == 0  # Use size attribute\n\n    def dequeue(self):\n        if not self.isNull():\n            removed_item = self.queue[0]  # Access the front\n            self.queue.deleteItem(0)  # Remove from the front using deleteItem\n            self.size -= 1  # Update size\n            return removed_item\n        else:\n            raise IndexError(\"The queue is empty\")\n\n    def rear(self):\n        if not self.isNull():\n            return self.queue.last_node().value  # Access the last node's value\n        else:\n            return None\n\n    def peek(self):\n        if not self.isNull():\n            return self.queue[0]  # Access the front\n        else:\n            return None\n\n    def isFull(self):\n        return self.size == self.__class__.N\n\n    def display_queue(self):\n        self.queue.display()  # LinkedList's display method\n</code></pre>"},{"location":"queue/#class-definition","title":"Class Definition","text":"<p>The <code>Queue</code> class implements a First-In, First-Out (FIFO) data structure, where elements are added to the rear and removed from the front. It utilizes a <code>LinkedList</code> to store the queue elements.</p>"},{"location":"queue/#class-attributes","title":"Class Attributes","text":"<ul> <li><code>N = 20</code>: A class-level constant defining the maximum size of the queue.</li> </ul>"},{"location":"queue/#__init__self-paranone","title":"<code>__init__(self, para=None)</code>","text":"<ul> <li>Purpose: This is the constructor for the <code>Queue</code> class. It initializes a new queue object.</li> <li>Parameters:<ul> <li><code>para</code>: An optional <code>LinkedList</code> object. If provided, this linked list will be used as the underlying storage for the queue. If not provided, a new empty <code>LinkedList</code> is created.</li> </ul> </li> <li>Functionality:<ul> <li>It initializes the <code>self.queue</code> attribute with either the provided <code>LinkedList</code> or a new empty one.</li> <li>It initializes the <code>self.size</code> attribute to the current length of the <code>self.queue</code> using the <code>get_length()</code> method of the <code>LinkedList</code>.</li> </ul> </li> </ul>"},{"location":"queue/#enqueueself-new","title":"<code>enqueue(self, new)</code>","text":"<ul> <li>Purpose: Adds a new element to the rear (end) of the queue.</li> <li>Parameters:<ul> <li><code>new</code>: The element to be added to the queue.</li> </ul> </li> <li>Functionality:<ul> <li>It first checks if the queue is full using the <code>self.isFull()</code> method.</li> <li>If the queue is not full, it uses the <code>InsertAtEnd()</code> method of the underlying <code>LinkedList</code> to add the <code>new</code> element at the end of the list (which represents the rear of the queue).</li> <li>It then increments the <code>self.size</code> of the queue.</li> <li>If the queue is full, it raises an <code>IndexError</code> indicating that the queue is full.</li> </ul> </li> </ul>"},{"location":"queue/#isnullself","title":"<code>isNull(self)</code>","text":"<ul> <li>Purpose: Checks if the queue is empty.</li> <li>Functionality: It returns <code>True</code> if the <code>self.size</code> of the queue is 0, and <code>False</code> otherwise.</li> </ul>"},{"location":"queue/#dequeueself","title":"<code>dequeue(self)</code>","text":"<ul> <li>Purpose: Removes and returns the element from the front of the queue (the element that was added earliest).</li> <li>Functionality:<ul> <li>It first checks if the queue is empty using <code>self.isNull()</code>.</li> <li>If the queue is not empty, it retrieves the element at the front of the <code>LinkedList</code> using index <code>0</code> (<code>self.queue[0]</code>).</li> <li>It then removes this element from the front of the <code>LinkedList</code> using the <code>deleteItem(0)</code> method.</li> <li>It decrements the <code>self.size</code> of the queue.</li> <li>It returns the <code>removed_item</code>.</li> <li>If the queue is empty, it raises an <code>IndexError</code> indicating that the queue is empty.</li> </ul> </li> </ul>"},{"location":"queue/#rearself","title":"<code>rear(self)</code>","text":"<ul> <li>Purpose: Returns the element at the rear (end) of the queue without removing it.</li> <li>Functionality:<ul> <li>It first checks if the queue is empty using <code>self.isNull()</code>.</li> <li>If the queue is not empty, it accesses the last node of the <code>LinkedList</code> using <code>self.queue.last_node()</code> and returns its <code>value</code>.</li> <li>If the queue is empty, it returns <code>None</code>.</li> </ul> </li> </ul>"},{"location":"queue/#peekself","title":"<code>peek(self)</code>","text":"<ul> <li>Purpose: Returns the element at the front of the queue without removing it.</li> <li>Functionality:<ul> <li>It first checks if the queue is empty using <code>self.isNull()</code>.</li> <li>If the queue is not empty, it accesses the element at the front of the <code>LinkedList</code> using index <code>0</code> (<code>self.queue[0]</code>) and returns it.</li> <li>If the queue is empty, it returns <code>None</code>.</li> </ul> </li> </ul>"},{"location":"queue/#isfullself","title":"<code>isFull(self)</code>","text":"<ul> <li>Purpose: Checks if the queue is full (reached its maximum capacity).</li> <li>Functionality: It compares the current <code>self.size</code> of the queue with the maximum size <code>self.__class__.N</code> (which is 20). It returns <code>True</code> if the queue is full and <code>False</code> otherwise.</li> </ul>"},{"location":"queue/#display_queueself","title":"<code>display_queue(self)</code>","text":"<ul> <li>Purpose: Displays the elements currently in the queue.</li> <li>Functionality: It calls the <code>display()</code> method of the underlying <code>LinkedList</code> to print the elements of the queue. The order of elements in the linked list represents the order in the queue (front to rear).</li> </ul> <pre><code>## Example Usage of the `Queue` Class\n\nThis section demonstrates how to create and interact with `Queue` objects, showcasing the enqueue, dequeue, peek, and isEmpty operations.\n\n```python\nfrom data_structures.queue import Queue # Assuming your Queue class is in 'queue.py'\nfrom data_structures.linked_lists import LinkedList\n\n# Initialize a queue using a LinkedList (implicitly, as no LinkedList is passed)\nmy_queue = Queue()\n\n# Enqueue elements\nmy_queue.enqueue(10)\nmy_queue.enqueue(20)\nmy_queue.enqueue(30)\n\n# Display the queue\nmy_queue.display_queue()  # Output: 10-&gt;20-&gt;30-&gt;\n\n# Dequeue an element\nremoved_element = my_queue.dequeue()\nprint(f\"Removed element: {removed_element}\")  # Output: Removed element: 10\n\n# Display the queue after dequeue\nmy_queue.display_queue()  # Output: 20-&gt;30-&gt;\n\n# Peek at the front element\nfront_element = my_queue.peek()\nprint(f\"Front element: {front_element}\")  # Output: Front element: 20\n\n# Check if the queue is empty\nis_empty = my_queue.isNull()\nprint(f\"Is queue empty: {is_empty}\")  # Output: Is queue empty: False\n</code></pre> <p>Explanation of the Example:</p> <ol> <li> <p>Initializing a Queue: <code>python     my_queue = Queue()</code>     An instance of the <code>Queue</code> class is created. Since no <code>LinkedList</code> object is explicitly passed during initialization, the <code>Queue</code> constructor creates a new empty <code>LinkedList</code> to serve as the underlying storage.</p> </li> <li> <p>Enqueueing Elements: <code>python     my_queue.enqueue(10)     my_queue.enqueue(20)     my_queue.enqueue(30)</code>     The <code>enqueue()</code> method adds elements to the rear of the queue. Here, <code>10</code> is added first, then <code>20</code>, and finally <code>30</code>. The <code>LinkedList</code>'s <code>InsertAtEnd()</code> method is used for this operation.</p> </li> <li> <p>Displaying the Queue: <code>python     my_queue.display_queue()  # Output: 10-&gt;20-&gt;30-&gt;</code>     The <code>display_queue()</code> method calls the <code>display()</code> method of the underlying <code>LinkedList</code>, which prints the elements from the front to the rear of the queue.</p> </li> <li> <p>Dequeueing an Element: <code>python     removed_element = my_queue.dequeue()     print(f\"Removed element: {removed_element}\")  # Output: Removed element: 10</code>     The <code>dequeue()</code> method removes and returns the element at the front of the queue (the element that was enqueued first). Here, <code>10</code> is removed. The <code>LinkedList</code>'s element at index <code>0</code> is accessed and then deleted using <code>deleteItem(0)</code>.</p> </li> <li> <p>Displaying After Dequeue: <code>python     my_queue.display_queue()  # Output: 20-&gt;30-&gt;</code>     After dequeueing, the <code>display_queue()</code> method shows the remaining elements in the queue, with <code>20</code> now at the front.</p> </li> <li> <p>Peeking at the Front: <code>python     front_element = my_queue.peek()     print(f\"Front element: {front_element}\")  # Output: Front element: 20</code>     The <code>peek()</code> method returns the element at the front of the queue without removing it. Here, it returns <code>20</code>.</p> </li> <li> <p>Checking if Empty: <code>python     is_empty = my_queue.isNull()     print(f\"Is queue empty: {is_empty}\")  # Output: Is queue empty: False</code>     The <code>isNull()</code> method checks if the queue is empty by examining its size. Since there are still elements in the queue, it returns <code>False</code>.</p> </li> </ol> <p>```</p>"},{"location":"stack/","title":"Stack","text":"<pre><code># The `Stack` Class: A Stack Implementation\n\nThis document describes the `Stack` class, which provides an implementation of the stack data structure. This implementation is versatile as it can be initialized using either our custom `Array_new` class or a `LinkedList` (assumed to be from a `linked_lists` module).\n\n```python\nfrom data_structures.linked_lists import LinkedList\nfrom data_structures.array import Array_new\n# Add features to handle linked lists\n\n# Add features to handle linked lists\n\nclass Stack:\n    def __init__(self, para):\n      self.stack = para\n      self.size = self.size_stack()\n\n    def __str__(self):\n      if type(self.stack) == Array_new:\n        return f\"{self.stack}\"\n\n    def push(self,newElement):\n      \"\"\"This insert an element at the top of the stack.\"\"\"\n      if type(self.stack) == Array_new:\n        a = [newElement] + [s for s in self.stack]\n        self.stack = Array_new(a)\n        self.size += 1\n\n      if type(self.stack) == LinkedList:\n        self.stack.InsertAtBeg(newElement)\n        self.size += 1\n\n\n    def peek(self):\n      \"\"\"Return the top element of the stack without removing it.\"\"\"\n      if not self.isEmpty():\n        if type(self.stack) == Array_new:\n          return self.stack[0]\n        elif type(self.stack) == LinkedList:\n          return self.stack.access(0)\n      else:\n        raise IndexError(\"Empty stack\")\n\n    def pop_stack(self):\n      \"\"\"Remove and return the top element of the stack.\"\"\"\n      if type(self.stack) == Array_new:\n        if not self.isEmpty():\n          a = self.stack[0]\n          self.stack = Array_new(self.stack[1:])\n          self.size -= 1\n          return a\n        else:\n          raise IndexError(\"pop from empty stack\")\n\n      if type(self.stack) == LinkedList:\n        if not self.isEmpty():\n          top_element = self.stack.access(0)\n          self.stack.deleteItem(0)\n          self.size -= 1\n          return top_element\n        else:\n          raise IndexError(\"pop from empty stack\")\n\n    def top(self):\n      \"\"\"Alias for peek(). Return the top element of the stack without removing it.\"\"\"\n      return self.peek()\n\n    def isEmpty(self):\n      \"\"\"Checks if the stack is empty.\"\"\"\n      return self.size_stack() == 0\n\n\n    def size_stack(self):\n      \"\"\"Returns the current size of the stack.\"\"\"\n      if type(self.stack) == LinkedList:\n        return self.stack.get_length()\n\n      if type(self.stack) == Array_new:\n        return len(self.stack)\n\n    def display_stack(self):\n      \"\"\"Displays the elements of the stack.\"\"\"\n      print(\"Top -&gt; \", end=\"\")\n      if type(self.stack) == LinkedList:\n        self.stack.display()\n      elif type(self.stack) == Array_new:\n        for i in range(len(self.stack)):\n          print(self.stack[i], end=\" -&gt; \")\n        print(\"None\")\n</code></pre>"},{"location":"stack/#__init__self-para","title":"<code>__init__(self, para)</code>","text":"<ul> <li>Purpose: This is the constructor for the <code>Stack</code> class. It initializes a new stack object based on the provided parameter.</li> <li>Parameters:<ul> <li><code>para</code>: This parameter can be either an instance of the <code>Array_new</code> class or an instance of the <code>LinkedList</code> class. This allows the stack to be implemented using either of these underlying data structures.</li> </ul> </li> <li>Functionality:<ul> <li>It sets the <code>self.stack</code> attribute to the provided <code>para</code>.</li> <li>It initializes the <code>self.size</code> attribute by calling the <code>self.size_stack()</code> method to determine the initial size of the stack based on the underlying data structure.</li> </ul> </li> </ul>"},{"location":"stack/#__str__self","title":"<code>__str__(self)</code>","text":"<ul> <li>Purpose: This special method defines how the <code>Stack</code> object should be represented as a string.</li> <li>Functionality: Currently, it only provides a string representation if the underlying stack is an <code>Array_new</code> object, returning the string representation of that <code>Array_new</code> object.</li> </ul>"},{"location":"stack/#pushself-newelement","title":"<code>push(self, newElement)</code>","text":"<ul> <li>Purpose: Adds a <code>newElement</code> to the top of the stack.</li> <li>Parameters:<ul> <li><code>newElement</code>: The element to be added to the stack.</li> </ul> </li> <li>Functionality:<ul> <li>If the stack is based on <code>Array_new</code>: It creates a new <code>Array_new</code> with the <code>newElement</code> at the beginning, effectively pushing it onto the top. The <code>self.stack</code> is updated with this new array, and the <code>self.size</code> is incremented.</li> <li>If the stack is based on <code>LinkedList</code>: It uses the <code>InsertAtBeg()</code> method of the <code>LinkedList</code> to add the <code>newElement</code> at the beginning (which represents the top of the stack), and the <code>self.size</code> is incremented.</li> </ul> </li> </ul>"},{"location":"stack/#peekself","title":"<code>peek(self)</code>","text":"<ul> <li>Purpose: Returns the element at the top of the stack without removing it.</li> <li>Functionality:<ul> <li>It first checks if the stack is empty using <code>self.isEmpty()</code>. If it is, it raises an <code>IndexError</code>.</li> <li>If the stack is based on <code>Array_new</code>: It returns the element at index <code>0</code>, which represents the top of the stack.</li> <li>If the stack is based on <code>LinkedList</code>: It returns the element at the beginning (index <code>0</code>) using the <code>access()</code> method of the <code>LinkedList</code>.</li> </ul> </li> </ul>"},{"location":"stack/#pop_stackself","title":"<code>pop_stack(self)</code>","text":"<ul> <li>Purpose: Removes and returns the element at the top of the stack.</li> <li>Functionality:<ul> <li>It first checks if the stack is empty. If it is, it raises an <code>IndexError</code>.</li> <li>If the stack is based on <code>Array_new</code>:<ul> <li>It retrieves the element at index <code>0</code> (the top).</li> <li>It creates a new <code>Array_new</code> containing all elements from index <code>1</code> onwards, effectively removing the top element.</li> <li>It updates <code>self.stack</code> with this new array and decrements <code>self.size</code>.</li> <li>It returns the removed <code>top_element</code>.</li> </ul> </li> <li>If the stack is based on <code>LinkedList</code>:<ul> <li>It retrieves the element at index <code>0</code> (the top) using <code>access()</code>.</li> <li>It uses the <code>deleteItem(0)</code> method of the <code>LinkedList</code> to remove the first element.</li> <li>It decrements <code>self.size</code>.</li> <li>It returns the removed <code>top_element</code>.</li> </ul> </li> </ul> </li> </ul>"},{"location":"stack/#topself","title":"<code>top(self)</code>","text":"<ul> <li>Purpose: This method is an alias for <code>peek()</code>, providing an alternative name to retrieve the top element of the stack without removal.</li> </ul>"},{"location":"stack/#isemptyself","title":"<code>isEmpty(self)</code>","text":"<ul> <li>Purpose: Checks if the stack is currently empty.</li> <li>Functionality: It calls the <code>self.size_stack()</code> method and returns <code>True</code> if the size is 0, and <code>False</code> otherwise.</li> </ul>"},{"location":"stack/#size_stackself","title":"<code>size_stack(self)</code>","text":"<ul> <li>Purpose: Returns the current number of elements in the stack.</li> <li>Functionality:<ul> <li>If the stack is based on <code>LinkedList</code>: It returns the length of the linked list using the <code>get_length()</code> method.</li> <li>If the stack is based on <code>Array_new</code>: It returns the number of elements in the array using the <code>len()</code> function.</li> </ul> </li> </ul>"},{"location":"stack/#display_stackself","title":"<code>display_stack(self)</code>","text":"<ul> <li>Purpose: Displays the elements of the stack, indicating the top.</li> <li>Functionality:<ul> <li>It prints \"Top -&gt; \" to indicate the top of the stack.</li> <li>If the stack is based on <code>LinkedList</code>: It calls the <code>display()</code> method of the <code>LinkedList</code> to print its elements.</li> <li>If the stack is based on <code>Array_new</code>: It iterates through the elements of the array and prints each element followed by \" -&gt; \", ending with \"None\" to signify the bottom of the stack.</li> </ul> </li> </ul> <pre><code>\n\n\n## Example Usage of the `Stack` Class with `Array_new`\n\nThis section demonstrates how to create and manipulate a `Stack` object when it is initialized with an `Array_new` object.\n\n\n```python\nfrom data_structures.array import Array_new\nfrom data_structures.stack import Stack \n\n# Create an Array_new object\npara = Array_new([1, 2, 3, 4, 5])\n\n# Create a Stack using the Array_new object\nmy_stack = Stack(para)\n\n# Push elements onto the stack\nmy_stack.push(6)  # Push 6 at the beginning\nmy_stack.push(7)  # Push 7\n\n# Display the stack\nmy_stack.display_stack()  # Output: Top -&gt; 7 -&gt; 6 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None\n\n# Peek at the top element\ntop_element = my_stack.peek()\nprint(f\"Top element: {top_element}\")  # Output: Top element: 7\n\n# Pop an element\npopped_element = my_stack.pop_stack()\nprint(f\"Popped element: {popped_element}\")  # Output: Popped element: 7\n\n# Display the stack again\nmy_stack.display_stack()  # Output: Top -&gt; 6 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None\n</code></pre> <p>Explanation of the Example:</p> <ol> <li> <p>Creating an <code>Array_new</code> Object: <code>python     para = Array_new([1, 2, 3, 4, 5])</code>     An instance of the <code>Array_new</code> class is created with initial elements <code>[1, 2, 3, 4, 5]</code>.</p> </li> <li> <p>Creating a <code>Stack</code> Object: <code>python     my_stack = Stack(para)</code>     A <code>Stack</code> object <code>my_stack</code> is created, initialized with the <code>para</code> (our <code>Array_new</code> object). This means the stack's underlying storage is an <code>Array_new</code>.</p> </li> <li> <p>Pushing Elements: <code>python     my_stack.push(6)  # Push 6 at the beginning     my_stack.push(7)  # Push 7</code>     The <code>push()</code> method adds new elements to the top of the stack. Since the underlying structure is <code>Array_new</code>, the <code>push()</code> operation effectively inserts the new element at the beginning of the array. Therefore, <code>6</code> is added before <code>[1, 2, 3, 4, 5]</code>, resulting in <code>[6, 1, 2, 3, 4, 5]</code>, and then <code>7</code> is added before that, resulting in <code>[7, 6, 1, 2, 3, 4, 5]</code>.</p> </li> <li> <p>Displaying the Stack: <code>python     my_stack.display_stack()  # Output: Top -&gt; 7 -&gt; 6 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None</code>     The <code>display_stack()</code> method iterates through the <code>Array_new</code> and prints the elements, indicating the top of the stack (the first element).</p> </li> <li> <p>Peeking at the Top Element: <code>python     top_element = my_stack.peek()     print(f\"Top element: {top_element}\")  # Output: Top element: 7</code>     The <code>peek()</code> method returns the element at the top of the stack (the first element in the <code>Array_new</code>) without removing it.</p> </li> <li> <p>Popping an Element: <code>python     popped_element = my_stack.pop_stack()     print(f\"Popped element: {popped_element}\")  # Output: Popped element: 7</code>     The <code>pop_stack()</code> method removes and returns the element at the top of the stack (the first element in the <code>Array_new</code>).</p> </li> <li> <p>Displaying the Stack Again: <code>python     my_stack.display_stack()  # Output: Top -&gt; 6 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None</code>     After the <code>pop()</code> operation, the top element (<code>7</code>) has been removed, and the stack now starts with <code>6</code>. The <code>display_stack()</code> method shows the updated stack.</p> </li> </ol>"},{"location":"stack/#example-usage-of-the-stack-class-with-linkedlist","title":"Example Usage of the <code>Stack</code> Class with <code>LinkedList</code>","text":"<p>This section demonstrates how to create and manipulate a <code>Stack</code> object when it is initialized with a <code>LinkedList</code> object. We assume that the <code>LinkedList</code> class (with <code>InsertAtEnd</code>, <code>InsertAtBeg</code>, <code>display</code>, <code>access</code>, and <code>deleteItem</code> methods) is available from the <code>data_structures.linked_lists</code> module.</p> <pre><code>from data_structures.linked_lists import LinkedList\nfrom data_structures.stack import Stack \n\n# Create a LinkedList object\nmy_linked_list = LinkedList(True)\nmy_linked_list.InsertAtEnd(1)\nmy_linked_list.InsertAtEnd(2)\nmy_linked_list.InsertAtEnd(3)\n\n\n# Create a Stack using the LinkedList object\nmy_stack_ll = Stack(my_linked_list)\n\n# Push elements onto the stack\nmy_stack_ll.push(4)  # Push 4 to the beginning (top of the stack)\nmy_stack_ll.push(5)  # Push 5 to the beginning (new top of the stack)\n\n\n# Display the stack\nmy_stack_ll.display_stack()  # Output: Top -&gt; 5&lt;--&gt;4&lt;--&gt;1&lt;--&gt;2&lt;--&gt;3&lt;--&gt;None\n\n# Peek at the top element\ntop_element_ll = my_stack_ll.peek()\nprint(f\"Top element: {top_element_ll}\")  # Output: Top element: 5\n\n# Pop an element from the stack\npopped_element_ll = my_stack_ll.pop_stack()\nprint(f\"Popped element: {popped_element_ll}\")  # Output: Popped element: 5\n\n# Display the stack again\nmy_stack_ll.display_stack()  # Output: Top -&gt; 4&lt;--&gt;1&lt;--&gt;2&lt;--&gt;3&lt;--&gt;None\n</code></pre> <p>Explanation of the Example:</p> <ol> <li> <p>Creating a <code>LinkedList</code> Object: <code>python     my_linked_list = LinkedList(True)     my_linked_list.InsertAtEnd(1)     my_linked_list.InsertAtEnd(2)     my_linked_list.InsertAtEnd(3)</code>     An instance of the <code>LinkedList</code> class (assuming it supports doubly linked lists as indicated by <code>True</code>) is created, and elements <code>1</code>, <code>2</code>, and <code>3</code> are inserted at the end of the list. In a stack context using a linked list, the beginning of the list typically represents the top of the stack.</p> </li> <li> <p>Creating a <code>Stack</code> Object with <code>LinkedList</code>: <code>python     my_stack_ll = Stack(my_linked_list)</code>     A <code>Stack</code> object <code>my_stack_ll</code> is created, initialized with the <code>my_linked_list</code>. This means the stack's underlying storage is now a linked list.</p> </li> <li> <p>Pushing Elements: <code>python     my_stack_ll.push(4)  # Push 4 to the beginning     my_stack_ll.push(5)  # Push 5 to the beginning</code>     The <code>push()</code> method, when the stack is based on a <code>LinkedList</code>, uses the <code>InsertAtBeg()</code> method of the linked list. This effectively adds the new element at the beginning of the list, making it the new top of the stack. So, <code>4</code> is added at the beginning, and then <code>5</code> is added at the very beginning.</p> </li> <li> <p>Displaying the Stack: <code>python     my_stack_ll.display_stack()  # Output: Top -&gt; 5&lt;--&gt;4&lt;--&gt;1&lt;--&gt;2&lt;--&gt;3&lt;--&gt;None</code>     The <code>display_stack()</code> method, for a <code>LinkedList</code>-based stack, calls the <code>display()</code> method of the linked list. Assuming the <code>display()</code> method prints the list from head to tail, and the head represents the top of the stack, the output shows the elements in the order of the stack (top to bottom).</p> </li> <li> <p>Peeking at the Top Element: <code>python     top_element_ll = my_stack_ll.peek()     print(f\"Top element: {top_element_ll}\")  # Output: Top element: 5</code>     The <code>peek()</code> method for a <code>LinkedList</code>-based stack uses <code>access(0)</code> to return the element at the beginning of the list (the top of the stack) without removing it.</p> </li> <li> <p>Popping an Element: <code>python     popped_element_ll = my_stack_ll.pop_stack()     print(f\"Popped element: {popped_element_ll}\")  # Output: Popped element: 5</code>     The <code>pop_stack()</code> method for a <code>LinkedList</code>-based stack uses <code>deleteItem(0)</code> to remove the element at the beginning of the list (the top) and returns its value using <code>access(0)</code> before deletion.</p> </li> <li> <p>Displaying the Stack Again: <code>python     my_stack_ll.display_stack()  # Output: Top -&gt; 4&lt;--&gt;1&lt;--&gt;2&lt;--&gt;3&lt;--&gt;None</code>     After the <code>pop()</code> operation, the top element (<code>5</code>) has been removed, and the new top of the stack is <code>4</code>. The <code>display_stack()</code> method shows the updated linked list representing the stack.     ```</p> </li> </ol>"},{"location":"tree/","title":"Binary Tree","text":"<pre><code># The  `BinaryTree` Class for Binary Tree Implementation\n\n\nThe `Node` class provides the basic structure for a tree node with a value and references to left and right children, along with methods for building and drawing a graph representation.\n\n## `BinaryTree` Class\n\nThe `BinaryTree` class inherits from the `Node` class and provides specific methods for binary tree operations, such as different types of traversals (pre-order, in-order, post-order) and searching for nodes.\n\n```python \nclass BinaryTree(Node):\n  def __init__(self, value = None, l = None, r = None):\n    self.root = self\n    Node.__init__(self, value, l, r)\n\n  def __str__(self) -&gt; str:\n    return str(self.value)\n\n  def pre_order(self):\n    if not self:\n      return\n    tem = self.root\n    print(tem.value)\n    if tem.left:\n      tem.left.pre_order()\n    if tem.right:\n      tem.right.pre_order()\n  def in_order(self):\n    if not self:\n      return\n    tem = self.root\n    if tem.left:\n      tem.left.in_order()\n    print(tem.value)\n    if tem.right:\n      tem.right.in_order()\n\n  def post_order(self):\n    if not self:\n      return\n    tem = self.root\n    if tem.left:\n      tem.left.post_order()\n    if tem.right:\n      tem.right.post_order()\n    print(tem.value)\n\n  def search_node(self, target):\n    if not self.root:\n      return False\n    if self.value == target:\n      return True\n    # Calling search_node on children.\n    if self.left and self.left.search_node(target):\n      return True\n    if self.right and self.right.search_node(target):\n      return True\n    return False\n\n  def search_BST(self, target):\n    if not self.root:\n      return False\n    if self.value == target:\n      return True\n    if target &lt; self.value and self.left: return self.left.search_BST(target)\n    elif target &gt;= self.value and self.right: return self.right.search_BST(target)\n    return False\n\n  def addnode(self, data):\n    newNode = BinaryTree(data)\n    if self.root is None:\n      self.root = newNode\n      return\n\n    current = self.root\n    while True:\n      if data &lt; current.value:\n        if current.left is None:\n          current.left = newNode\n          return\n        current = current.left\n      else:\n        if current.right is None:\n          current.right = newNode\n          return\n        current = current.right\n\n\ndef delete_node_bst(root, key):\n\n  def find_min(node):\n    current = node\n    while current.left is not None:\n      current = current.left\n    return current\n\n  def find_max(node):\n    current = node\n    while current.right is not None:\n      current = current.right\n    return current\n\n    if not root:\n      return root\n\n  if key &lt; root.value:\n      root.left = delete_node_bst(root.left, key)\n  elif key &gt; root.value:\n      root.right = delete_node_bst(root.right, key)\n  else:  # Key is equal to root's data (node to be deleted)\n      # Case 1: Leaf node\n      if root.left is None and root.right is None:\n          root = None\n      # Case 2: Node with one child\n      elif root.left is None:\n          root = root.right\n      elif root.right is None:\n          root = root.left\n      # Case 3: Node with two children\n      else:\n          # Find the inorder successor (smallest in the right subtree)\n          successor = find_min(root.right)\n          # Replace the current node's data with the successor's data\n          root.value = successor.value\n          # Delete the successor from the right subtree\n          root.right = delete_node_bst(root.right, successor.value)\n\n  return root\n</code></pre>"},{"location":"tree/#__init__self-valuenone-lnone-rnone","title":"<code>__init__(self, value=None, l=None, r=None)</code>","text":"<ul> <li>Purpose: This is the constructor for the <code>BinaryTree</code> class. It initializes a new binary tree node.</li> <li>Parameters:<ul> <li><code>value</code>: The data to be stored in this node. Defaults to <code>None</code>.</li> <li><code>l</code>: An optional reference to the left child node. Defaults to <code>None</code>.</li> <li><code>r</code>: An optional reference to the right child node. Defaults to <code>None</code>.</li> </ul> </li> <li>Functionality: It calls the <code>__init__</code> of the parent <code>Node</code> class to initialize the <code>value</code>, <code>left</code>, and <code>right</code> attributes. It also sets <code>self.root</code> to <code>self</code>, making the current instance the root of the (sub)tree.</li> </ul>"},{"location":"tree/#__str__self-str","title":"<code>__str__(self) -&gt; str</code>","text":"<ul> <li>Purpose: Defines how the <code>BinaryTree</code> object should be represented as a string.</li> <li>Functionality: It returns the string representation of the node's <code>value</code>.</li> </ul>"},{"location":"tree/#pre_orderself","title":"<code>pre_order(self)</code>","text":"<ul> <li>Purpose: Performs a pre-order traversal of the binary tree (Root -&gt; Left -&gt; Right).</li> <li>Functionality:<ul> <li>If the current node is not <code>None</code>, it prints the node's <code>value</code>.</li> <li>Then, it recursively calls <code>pre_order</code> on the left child.</li> <li>Finally, it recursively calls <code>pre_order</code> on the right child.</li> </ul> </li> </ul>"},{"location":"tree/#in_orderself","title":"<code>in_order(self)</code>","text":"<ul> <li>Purpose: Performs an in-order traversal of the binary tree (Left -&gt; Root -&gt; Right).</li> <li>Functionality:<ul> <li>If the current node is not <code>None</code>, it recursively calls <code>in_order</code> on the left child.</li> <li>Then, it prints the node's <code>value</code>.</li> <li>Finally, it recursively calls <code>in_order</code> on the right child.</li> </ul> </li> </ul>"},{"location":"tree/#post_orderself","title":"<code>post_order(self)</code>","text":"<ul> <li>Purpose: Performs a post-order traversal of the binary tree (Left -&gt; Right -&gt; Root).</li> <li>Functionality:<ul> <li>If the current node is not <code>None</code>, it recursively calls <code>post_order</code> on the left child.</li> <li>Then, it recursively calls <code>post_order</code> on the right child.</li> <li>Finally, it prints the node's <code>value</code>.</li> </ul> </li> </ul>"},{"location":"tree/#search_nodeself-target","title":"<code>search_node(self, target)</code>","text":"<ul> <li>Purpose: Searches for a node with a specific <code>target</code> value in the binary tree.</li> <li>Parameters:<ul> <li><code>target</code>: The value to search for.</li> </ul> </li> <li>Functionality:<ul> <li>If the current node (or root) is <code>None</code>, it returns <code>False</code>.</li> <li>If the current node's <code>value</code> matches the <code>target</code>, it returns <code>True</code>.</li> <li>Otherwise, it recursively calls <code>search_node</code> on the left and right children. If either of these calls returns <code>True</code>, the method returns <code>True</code>.</li> <li>If the <code>target</code> is not found in the current node or its subtrees, it returns <code>False</code>.</li> </ul> </li> </ul>"},{"location":"tree/#search_bstself-target","title":"<code>search_BST(self, target)</code>","text":"<ul> <li>Purpose: Searches for a <code>target</code> value in a Binary Search Tree (BST). This method assumes the tree follows the BST property (left child's value is less than the parent, right child's value is greater than or equal to the parent).</li> <li>Parameters:<ul> <li><code>target</code>: The value to search for.</li> </ul> </li> <li>Functionality:<ul> <li>If the current node (or root) is <code>None</code>, it returns <code>False</code>.</li> <li>If the current node's <code>value</code> matches the <code>target</code>, it returns <code>True</code>.</li> <li>If the <code>target</code> is less than the current node's <code>value</code> and the left child exists, it recursively calls <code>search_BST</code> on the left child.</li> <li>If the <code>target</code> is greater than or equal to the current node's <code>value</code> and the right child exists, it recursively calls <code>search_BST</code> on the right child.</li> <li>If the <code>target</code> is not found based on these comparisons, it returns <code>False</code>.</li> </ul> </li> </ul>"},{"location":"tree/#addnodeself-data","title":"<code>addnode(self, data)</code>","text":"<ul> <li>Purpose: Adds a new node with the given <code>data</code> to the Binary Search Tree (BST), maintaining the BST property.</li> <li>Parameters:<ul> <li><code>data</code>: The value to be inserted into the BST.</li> </ul> </li> <li>Functionality:<ul> <li>It creates a new <code>BinaryTree</code> node with the given <code>data</code>.</li> <li>If the tree is empty (root is <code>None</code>), the new node becomes the root.</li> <li>Otherwise, it starts from the root and traverses down the tree.</li> <li>If <code>data</code> is less than the current node's <code>value</code>, it moves to the left child. If the left child is <code>None</code>, the new node is inserted as the left child.</li> <li>If <code>data</code> is greater than or equal to the current node's <code>value</code>, it moves to the right child. If the right child is <code>None</code>, the new node is inserted as the right child.</li> <li>This process continues until an appropriate empty position is found for the new node.</li> </ul> </li> </ul>"},{"location":"tree/#delete_node_bstroot-key-function","title":"<code>delete_node_bst(root, key)</code> (Function)","text":"<ul> <li>Purpose: Deletes a node with a specific <code>key</code> from a Binary Search Tree (BST), maintaining the BST property. This is a standalone function, not a method of the <code>BinaryTree</code> class.</li> <li>Parameters:<ul> <li><code>root</code>: The root node of the BST.</li> <li><code>key</code>: The value of the node to be deleted.</li> </ul> </li> <li>Functionality:<ul> <li>It includes helper functions <code>find_min</code> (to find the minimum value in a subtree) and <code>find_max</code> (to find the maximum value in a subtree), although <code>find_max</code> is not used in this specific implementation.</li> <li>If the <code>root</code> is <code>None</code>, it returns <code>None</code>.</li> <li>If the <code>key</code> is less than the <code>root</code>'s <code>value</code>, it recursively calls <code>delete_node_bst</code> on the left subtree.</li> <li>If the <code>key</code> is greater than the <code>root</code>'s <code>value</code>, it recursively calls <code>delete_node_bst</code> on the right subtree.</li> <li>If the <code>key</code> is equal to the <code>root</code>'s <code>value</code> (the node to be deleted):<ul> <li>Case 1: Leaf node: If the node has no children, it is simply set to <code>None</code>.</li> <li>Case 2: Node with one child: If the node has only a left or a right child, it is replaced by its child.</li> <li>Case 3: Node with two children:<ul> <li>It finds the inorder successor (the smallest node in the right subtree) using <code>find_min</code>.</li> <li>It replaces the current node's <code>value</code> with the <code>value</code> of the successor.</li> <li>It then recursively deletes the successor from the right subtree.</li> </ul> </li> </ul> </li> <li>Finally, it returns the modified <code>root</code> of the subtree.</li> </ul> </li> </ul>"},{"location":"tree/#example-usage-of-the-binarytree-class","title":"Example Usage of the <code>BinaryTree</code> Class","text":"<pre><code># Creating a Binary Search Tree and adding nodes\na = BinaryTree(8)\na.left = BinaryTree(3)\na.right = BinaryTree(10)\na.left.left = BinaryTree(1)\na.left.right = BinaryTree(6)\na.left.right.right = BinaryTree(7)\na.left.right.left = BinaryTree(4)\na.right.right = BinaryTree(14)\na.right.right.left = BinaryTree(13)\na.addnode(9)\na.addnode(20)\na.addnode(2)\n\n# Drawing the graph of the BST\na.draw_graph()\n\n# Searching for a node in the BST\nprint(f\"Search for 20 in BST: {a.search_BST(20)}\")\n\nprint(\"\\n--- Example BST Deletion ---\")\n# Example BST for deletion\nroot = BinaryTree(50)\nroot.left = BinaryTree(30)\nroot.right = BinaryTree(70)\nroot.left.left = BinaryTree(20)\nroot.left.right = BinaryTree(40)\nroot.right.left = BinaryTree(60)\nroot.right.right = BinaryTree(80)\n\nprint(\"\\nPre-order traversal of the initial BST:\")\nroot.pre_order()\nroot.draw_graph()\n\n# Delete a leaf node (20)\nroot = delete_node_bst(root, 20)\nprint(\"\\nAfter deleting 20 (pre-order):\")\nroot.pre_order()\nroot.draw_graph()\n\n# Delete a node with one child (30)\nroot = delete_node_bst(root, 30)\nprint(\"\\nAfter deleting 30 (pre-order):\")\nroot.pre_order()\nroot.draw_graph()\n\n# Delete a node with two children (50)\nroot = delete_node_bst(root, 50)\nprint(\"\\nAfter deleting 50 (pre-order):\")\nroot.pre_order()\nroot.draw_graph()\n</code></pre> <p>Explanation of the Example:</p> <ol> <li> <p>Creating a Binary Search Tree and Adding Nodes:</p> <ul> <li>An initial binary tree structure is created.</li> <li>The <code>addnode()</code> method is then used to insert new nodes (<code>9</code>, <code>20</code>, <code>2</code>) into the tree while maintaining the Binary Search Tree (BST) property. The <code>addnode</code> method ensures that smaller values are inserted to the left and larger values to the right.</li> </ul> </li> <li> <p>Drawing the Graph:</p> <ul> <li><code>a.draw_graph()</code> visualizes the constructed BST using <code>networkx</code> and <code>matplotlib</code>.</li> </ul> </li> <li> <p>Searching in the BST:</p> <ul> <li><code>a.search_BST(20)</code> demonstrates how to search for a specific value (<code>20</code>) in the BST. The output <code>True</code> confirms that the node with the value <code>20</code> exists in the tree.</li> </ul> </li> <li> <p>BST Deletion Example:</p> <ul> <li>A new BST is created for demonstrating the <code>delete_node_bst</code> function.</li> <li>Pre-order Traversal: The <code>pre_order()</code> method is called to print the initial structure of the BST (Root -&gt; Left -&gt; Right).</li> <li>Deleting a Leaf Node (20): The <code>delete_node_bst(root, 20)</code> function is called to remove the leaf node with the value <code>20</code>. The subsequent pre-order traversal and graph drawing show the tree after deletion.</li> <li>Deleting a Node with One Child (30): <code>delete_node_bst(root, 30)</code> removes the node with value <code>30</code>, which has one child (<code>40</code>). The node is replaced by its child. The pre-order traversal and graph drawing reflect this change.</li> <li>Deleting a Node with Two Children (50): <code>delete_node_bst(root, 50)</code> removes the root node, which has two children. The inorder successor (the smallest node in the right subtree, which is <code>60</code>) replaces the root, and the successor is then deleted from its original position. The final pre-order traversal and graph drawing illustrate the BST after this deletion.</li> </ul> </li> </ol> <p>This example showcases the fundamental operations on a Binary Search Tree, including insertion (using <code>addnode</code>), searching (<code>search_BST</code>), traversal (<code>pre_order</code>), visualization (<code>draw_graph</code>), and deletion (<code>delete_node_bst</code>), highlighting how these operations maintain the BST properties where applicable.</p> <p>```</p>"}]}